---
title: "Final Project"
author: "Berta Canal & Adam Olivares"
date: "2023-11-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(glmnet)
library(sigmoid)
library(caret)
library(ggplot2)
library(dplyr)
library(tidyverse) # multipurpose package developped by Posit
library(rstanarm) # Easy estimation of standard models with Bayesian methods 
#library(bayestestR) # Functions to analyze posterior distributions generated by rstranarm
library(mombf) # Bayesian model selection and Bayesian model averaging
library(ltm) #croeelation for binary outcome
library(Hmisc) #describe
set.seed(1234)
```


```{r}
darwin <- read.csv("DARWIN.csv", sep = ",", header = TRUE)
```

```{r}
darwin_Y <- as.numeric(darwin$class %in% c("P")) #generate a dichotomous variable
darwin_x <- data.frame(darwin[, !colnames(darwin) %in% c("ID", "class")])
# darwin_x <- scale(darwin_x)
```

## Data exploration

Count the number of instances of each class (dependent variable:

```{r}
ggplot(darwin, aes(x = class)) +
  geom_bar()
```
```{r}
data.frame(summary(darwin_x))
```

The Point-Biserial Correlation Coefficient is a correlation measure of the strength of association between a continuous-level variable (ratio or interval data) and a binary variable.
```{r}
cor_test_results <- function(x_data, cutoff){
  
    coef <- sapply(x_data[, -ncol(x_data)], function(x) biserial.cor(x, darwin_Y)) #apply biserial.cor function
    status <- ifelse(abs(coef) >= cutoff, sprintf("above_%s", cutoff), sprintf("below_%s", cutoff))
    data.frame(
    #item = names(coef),
    biserial_correlation = matrix(coef),
    status = as.character(status), row.names = c(names(coef))
  )  
}
test <- cor_test_results(darwin_x, 0.2)
```

```{r}
test %>% count(status)
#test %>% biserial_correlation(status)
```
low variance features

```{r}
var_test_results <- function(x_data, cutoff){
  
    coef <- sapply(x_data[, -ncol(x_data)], function(x) var(x)) #apply biserial.cor function
    status <- ifelse(coef >= cutoff, sprintf("above_%s", cutoff), sprintf("below_%s", cutoff))
    data.frame(
    #item = names(coef),
    variance = matrix(round(coef,3)),
    status = as.character(status), row.names = c(names(coef))
  )  
}
var_test <- var_test_results(darwin_x, 0.1)
```

```{r}
var_test %>% count(status)
```

```{r}

correlations <- cor(darwin_x)
highCorr <- findCorrelation(correlations, cutoff = .85, names = TRUE)
print(highCorr)
new_darwin_x <- darwin_x[,!(names(darwin_x) %in% highCorr)] 
```


subset conditional on variables with virtually 0 variance i.e., almost constants:


### LASSO-CV (Via cross-validation)


```{r}
t0 <- Sys.time()
fit.lassocv <- cv.glmnet(x=darwin_x,y=darwin_Y,family ='binomial', nfolds = 10, aplha = 1)
t1 <- Sys.time()
cat('\nTime elapsed: ')
```


```{r}
print(round(t1-t0,3))
```

```{r}
fit.lassocv
```

```{r}
plot(fit.lassocv) 
```

```{r}
b.lassocv = as.vector(coef(fit.lassocv, s='lambda.min'))
sum(b.lassocv != 0)
```

### LASSO-BIC (Via BIC)

Now the $\lambda$ is set via BIC using the function `lasso.bic` from `routines_seminar1.R`.

```{r}
lasso.bic.logistic <- function(y,x,extended=FALSE) {
  #Select model in LASSO path with best BIC (using LASSO regression estimates)
  #Input
  # - y: vector with response variable
  # - x: design matrix
  #
  #Output: list with the following elements
  # - coef: LASSO-estimated regression coefficient with lambda set via BIC
  # - ypred: predicted y
  # - lambda.opt: optimal value of lambda
  # - lambda: data.frame with bic and number of selected variables for each value of lambda
  require(glmnet)
  fit <- glmnet(x=x,y=y,family='binomial',alpha=1)
  pred <- predict(fit,newx=x,type='response')
  n <- length(y)
  p <- colSums(fit$beta!=0) + 1
  if (!extended){
    bic <- -2* colSums(y*log(pred)+(1-y)*log(1-pred)) + log(n)*p 
  } else {
    bic <- -2* colSums(y*log(pred)+(1-y)*log(1-pred)) + log(n)*p + 2*log(choose(ncol(x),p))
  }
  sel <- which.min(bic)
  beta <- c(fit$a0[sel],fit$beta[,sel]); names(beta)[1]= 'Intercept'
  ypred <- pred[,sel]
  ans <- list(model=fit,coef=beta,ypred=ypred,lambda.opt=fit$lambda[sel],lambda=data.frame(lambda=fit$lambda,bic=bic,nvars=p))
  return(ans)
}
```

To use the BIC criteria, the parameter `extended` is set to `FALSE`.

```{r}
fit.lassobic = lasso.bic.logistic(x = new_darwin_x, y = darwin_Y, extended = FALSE)
b.lassobic = fit.lassobic$coef
names(fit.lassobic)
round(b.lassobic, 3)
```

The number of non-zero coefficients for LASSO-BIC corresponds to:
```{r}
sum(b.lassobic != 0)
```

```{r}
fit.bayesreg <- modelSelection(y= darwin_Y ,x= as.matrix(new_darwin_x), priorCoef=zellnerprior(tau=1), priorDelta=modelbbprior(1,1))
```

```{r}
ci.bayesreg <- coef(fit.bayesreg)[-c(1,nrow(coef(fit.bayesreg))),]
sel.bayesreg <- ci.bayesreg[,4] > 0.5
ci.bayesreg[,1:3] <- round(ci.bayesreg[,1:3], 3)  
ci.bayesreg[,4] <- round(ci.bayesreg[,4], 4)      
head(ci.bayesreg)
tail(ci.bayesreg)
```



